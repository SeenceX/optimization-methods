import numpy as np


def newton_hessian(f, grad, hess, x0, e1, e2, M):
    """
    Метод Ньютона для минимизации целевой функции f(x) при помощи матрицы Гессе.

    Аргументы:
    - f: функция цели (целевая функция)
    - grad: функция для вычисления градиента функции f(x)
    - hess: функция для вычисления матрицы Гессе функции f(x)
    - x0: начальное приближение (вектор размерности n)
    - e1: первая допустимая погрешность по x (по умолчанию 0.15)
    - e2: вторая допустимая погрешность по функции (по умолчанию 0.20)
    - M: максимальное число итераций (по умолчанию 10)

    Возвращает найденный минимум x.
    Если за максимальное число итераций минимум не найден с заданной точностью,
    то выбрасывается исключение ValueError.
    """

    for i in range(M):
        delta_x = np.linalg.solve(hess(x0), -grad(x0))
        x1 = x0 + delta_x
        if np.linalg.norm(delta_x) < e1 and abs(f(x1) - f(x0)) < e2:
            return x1
        x0 = x1

    raise ValueError("Метод Ньютона не сошелся за {} итераций".format(M))

# Определим функцию для минимизации
def f(x):
    return x[0]**3 + 0.6*x[0]*x[1] + 6*x[1]**2

# Определим функцию для вычисления градиента этой функции
def grad(x):
    return np.array([3*x[0]**2 + 0.6*x[1], 1.2*x[0] + 12*x[1]])

# Определим функцию для вычисления матрицы Гессе этой функции
def hess(x):
    return np.array([[6*x[0], 0.6], [0.6, 24]])

# Запустим метод Ньютона
x0 = np.array([1.5, 0.5])
e1 = 0.15
e2 = 0.20
M = 10
minimizer = newton_hessian(f, grad, hess, x0, e1, e2, M)

print("Найденный минимум: ", minimizer)
